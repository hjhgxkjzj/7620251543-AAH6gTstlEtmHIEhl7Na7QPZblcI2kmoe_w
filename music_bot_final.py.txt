import os
import yt_dlp
import hashlib
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InlineQueryResultAudio,
)
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    InlineQueryHandler,
    filters,
)

TOKEN = "7620251543:AAH6gTstlEtmHIEhl7Na7QPZblcI2kmoe_w"

# –ü–∞–ø–∫–∞ –∫—ç—à–∞
CACHE_DIR = "cache"
os.makedirs(CACHE_DIR, exist_ok=True)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ yt_dlp
ydl_opts = {
    'format': 'bestaudio/best',
    'noplaylist': True,
    'quiet': True,
    'outtmpl': os.path.join(CACHE_DIR, '%(id)s.%(ext)s'),
    'postprocessors': [{
        'key': 'FFmpegExtractAudio',
        'preferredcodec': 'mp3',
        'preferredquality': '192',
    }],
}

# –ö—ç—à: –∏—Å–ø–æ–ª—å–∑—É–µ–º id –≤–∏–¥–µ–æ –∫–∞–∫ –∏–º—è —Ñ–∞–π–ª–∞
def get_cached_filename(video_id):
    return os.path.join(CACHE_DIR, f"{video_id}.mp3")

# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –º—É–∑—ã–∫–∏.\n"
        "üîç –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏ –∏–ª–∏ —Å—Å—ã–ª–∫—É (YouTube, TikTok, Spotify –∏ —Ç.–¥.).\n"
        "üí° –¢–∞–∫–∂–µ —è –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é –∏–Ω–ª–∞–π–Ω-–ø–æ–∏—Å–∫: –Ω–∞–ø–∏—à–∏ @–∏–º—è_–±–æ—Ç–∞ –≤ –ª—é–±–æ–º —á–∞—Ç–µ."
    )

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.message.text
    await update.message.reply_text("üîé –ò—â—É –º—É–∑—ã–∫—É...")

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(query, download=True)
            video_id = info.get("id")
            title = info.get("title", "–ê—É–¥–∏–æ")
            url = info.get("webpage_url", "")
            thumb = info.get("thumbnail")
            filename = get_cached_filename(video_id)

        buttons = [[InlineKeyboardButton("üåê –û—Ç–∫—Ä—ã—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫", url=url)]]
        reply_markup = InlineKeyboardMarkup(buttons)

        with open(filename, 'rb') as f:
            await update.message.reply_audio(
                audio=f,
                title=title,
                caption=f"üéß {title}",
                thumbnail=thumb,
                reply_markup=reply_markup
            )

    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è –û—à–∏–±–∫–∞: {e}")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–Ω–ª–∞–π–Ω-–ø–æ–∏—Å–∫–∞
async def inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.inline_query.query
    results = []

    if not query:
        return

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(f"ytsearch5:{query}", download=False)['entries']
            for entry in info:
                video_id = entry.get("id")
                title = entry.get("title")
                audio_url = entry.get("url")
                performer = entry.get("uploader")

                result = InlineQueryResultAudio(
                    id=video_id,
                    title=title,
                    audio_url=audio_url,
                    performer=performer,
                    caption=f"üéµ {title}",
                )
                results.append(result)
    except Exception:
        pass

    await update.inline_query.answer(results[:5], cache_time=1)

# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
if __name__ == '__main__':
    app = ApplicationBuilder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(InlineQueryHandler(inline_query))
    print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω ‚úÖ")
    app.run_polling()